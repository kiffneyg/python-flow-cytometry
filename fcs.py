"""
FCS (Flow Cytometry Standard) files are described at
http://isac-net.org/PDFS/90/9090600d-19be-460d-83fc-f8a8b004e0f9.pdf
These files are generated by flow cytometry instruments 
(these are the machines that look at your blood sample and figure out
your red blood cell count, T-cell count, etc.)
 
this function takes a FCS file passed in the root_path parameter
and returns the metadata in the header as a JSON structure.
The rest of the file is a binary data array used to create graphs of the
prevalence of the various cells found in blood.

"""
import json

class FCSFormatError(Exception):
    pass
    
def parse_fcs(root_path):
    """FCS (Flow Cytometry Standard) files are described at
    http://isac-net.org/PDFS/90/9090600d-19be-460d-83fc-f8a8b004e0f9.pdf"""
    try:
        f = open(root_path, "r+b")
    except IOError:
        print ("File not found: {}".format(root_path))
        return
    with f:
        # is this even a valid FCS file? first 3 characters should say FCS
        version = f.read(3)
        if 'FCS' not in version:
            msg = "FCS file not in correct format: {root_path}".format(root_path=root_path)
            raise FCSFormatError(msg)
        f.seek(0, 0)
        header = f.read(42)
        # first 42 bytes of file is header; has version, byte offsets of text and data segs
        header = header.split()
        version = header.pop(0)
        header = map(int,header)
        f.seek(header[0]) # seek past header
        dat = f.read(header[1] - header[0]) # read text segment based on byte offsets
        dat = dat.decode('ISO-8859-1') # you might need something else; the OS for our machines happens to be Windows
        delim = dat[0] # first byte of text segment is the delimiter
        datl = dat[1:].split(delim)
        """ 
        the text part of fcs is one long string of key|value pairs, separated
        by |, so we take first thing = key, second thing = value, third thing = key,
        etc.
        """
        newzip = []
        for i in range(len(datl) - 1):
            if i % 2 == 0:
                newzip.append((datl[i], datl[i+1]))
        d = dict(newzip)
        metadata = json.dumps(d)
    return metadata
